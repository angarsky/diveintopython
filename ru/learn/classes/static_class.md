> [!NOTE]
> Вы можете прочитать эту статью на сайте: https://diveintopython.org/ru/learn/classes/static-class

Python предлагает различные типы классов, включая статические классы Python, которые позволяют вам определять функциональность на уровне класса без необходимости создания экземпляров. Одно из преимуществ использования статического класса заключается в том, что он позволяет вам группировать связанные функции внутри класса, интегрируя статические классы Python в ваши проекты на Python, вы можете использовать преимущества организованной функциональности на уровне класса, которая не зависит от экземпляров класса. Для создания статического метода в классе вы можете использовать декоратор `@staticmethod`. После создания вы можете вызывать статический метод напрямую из класса без создания экземпляра. В этой статье мы рассмотрим концепцию статических классов и как создавать и вызывать статический метод в классе.

## Понимание Статических Классов Python

Статический класс Python — это класс, создания экземпляра которого не требуется. Его создание происходит с использованием декоратора `@staticmethod` в определении класса. Статический метод не имеет доступа к экземпляру, и он также не может изменять сам класс.

### Как Использовать Статический Класс и Вызывать Статический Метод в Классе

Помимо понимания концепции статического метода, крайне важно осознать значение статического класса в Python.

```python
class MyClass:
    @staticmethod
    def static_method():
        print("This is a static method in a class")
        
MyClass.static_method()   # Output: This is a static method in a class
```

В приведенном выше примере, `static_method()` является статическим методом в `MyClass`. Его можно вызвать, используя имя класса без создания экземпляра класса.

```python
class Calculator:
    @staticmethod
    def add_numbers(x, y):
        return x + y
        
result = Calculator.add_numbers(3, 5)
print(result)   # Output: 8
```

В приведенном выше примере статический метод `add_numbers()` класса `Calculator` может быть вызван напрямую с использованием имени класса `Calculator`. Он принимает два аргумента `x` и `y` и возвращает их сумму.

В целом, статические классы и статические методы предоставляют способ представления функциональности, которая не зависит от каких-либо экземпляров или переменных класса и может быть использована без создания экземпляра класса.

## Что Такое Статический Метод в Python

Python позволяет создавать статические классы и статические методы внутри класса. Статический метод в Python не требует создания экземпляра класса перед его использованием. Тем временем, статический метод класса Python - это метод, первый параметр которого сам класс, а не экземпляр класса.

Чтобы создать статические классы и статические методы, мы просто используем декоратор `@staticmethod` в Python.

```python
class Math:
    @staticmethod
    def add(x, y):
        return x + y

    @staticmethod
    def subtract(x, y):
        return x - y
        
# To call the static methods in the class, we don't need to create an instance of the class
print(Math.add(2, 3))       # Output: 5
print(Math.subtract(5, 2))  # Output: 3
```

В приведенном выше примере мы создали **статический класс** под названием **Math**, который содержит два **статических метода**, называемых **add** и **subtract**. Мы можем вызывать эти методы напрямую из класса без необходимости создавать экземпляр класса.

```python
class Person:
    count = 0

    def __init__(self, name):
        self.name = name
        Person.count += 1

    @staticmethod
    def total_people():
        return f"There are {Person.count} people."

# Create some instances of Person
person1 = Person("John")
person2 = Person("Jane")
person3 = Person("Jack")

# Call the static method from the class
print(Person.total_people())  # Output: There are 3 people.
```

В этом примере мы создали класс `Person` с **классовой переменной** под названием `count`, которая будет отслеживать количество созданных экземпляров класса. Мы также создали **статический метод класса Python** под названием `total_people`, который будет возвращать общее количество созданных людей. Этот статический метод можно вызывать напрямую из класса.

## Как Вызвать Статический Метод в Классе

Чтобы вызвать статический метод в классе, вам нужно определить статический метод с использованием встроенного декоратора `@staticmethod`. Для вызова статического метода не требуется никакого экземпляра, вместо этого он ассоциируется сам с классом.

```python
class MyClass:
    
    @staticmethod  ### Defining static method

    def my_static_method():
        print("This is a static method.")
        
### Calling the static method using the class name

MyClass.my_static_method()   ### Output

```

```python
class Math:
    
    @staticmethod   ### Defining static method

    def add(a, b):
        return a + b

    @staticmethod  ### Defining static method

    def multiply(a, b):
        return a * b

### Calling the static methods in class using class name
print(Math.add(2, 3))      ### Output 5
print(Math.multiply(2, 3)) ### Output 6

```

В приведенных выше примерах мы можем увидеть, как определить и вызвать статический метод с использованием декоратора `@staticmethod` в Python.

## Когда Использовать Статические Методы

Статические методы в Python - это мощная функция, которая может существенно улучшить организацию кода и его поддерживаемость. Однако важно понимать, когда и где их эффективно использовать. Вот некоторые общие сценарии, в которых статические методы могут быть полезны:

### Вспомогательные Функции

Статические методы идеально подходят для вспомогательных функций, которые не привязаны к конкретному экземпляру класса. Эти функции предоставляют функциональность, которая может использоваться в различных частях вашего кода. Инкапсулируя их в статический метод, вы обеспечиваете чистую и модульную структуру, делая ваш код более поддерживаемым.

```python
class StringUtils:
    @staticmethod
    def reverse_string(string):
        return string[::-1]
```

В этом примере метод `reverse_string` является вспомогательной функцией, которая может быть использована для переворачивания строки. Он не требует доступа к данным конкретного экземпляра и может быть вызван непосредственно для класса.

### Фабричные Методы

Статические методы могут быть использованы для создания экземпляров класса. Это особенно полезно, когда вы хотите инкапсулировать логику создания объекта в самом классе. Фабричные методы упрощают процесс инициализации объекта и предоставляют четкие и краткие интерфейсы для создания объектов.

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    @staticmethod
    def create_square(side_length):
        return Rectangle(side_length, side_length)
```

В этом примере статический метод `create_square` является фабричным методом, который упрощает создание квадратных экземпляров `Rectangle`.

### Кэширование и Мемоизация

Статические методы могут быть использованы для целей кэширования или мемоизации. Когда вам нужно сохранить и повторно использовать рассчитанные результаты, статические методы могут помочь поддерживать кэш внутри класса, делая последующие расчеты более эффективными.

```python
class MathUtils:
    _fib_cache = {0: 0, 1: 1}

    @staticmethod
    def fibonacci(n):
        if n not in MathUtils._fib_cache:
            MathUtils._fib_cache[n] = MathUtils.fibonacci(n - 1) + MathUtils.fibonacci(n - 2)
        return MathUtils._fib_cache[n]
```

В этом примере статический метод `fibonacci` вычисляет числа Фибоначчи с использованием мемоизации для оптимизации производительности.

### Организация Кода

Используйте статические методы для группировки связанных функций внутри класса. Это улучшает организацию кода и его читаемость. Когда функции имеют общую цель, но не зависят от данных, специфичных для экземпляра, их инкапсуляция в виде статических методов внутри того же класса помогает структурировать ваш код.

```python
class FileUtils:
    @staticmethod
    def read_file(filename):
        # Read file content

    @staticmethod
    def write_file(filename, content):
        # Write content to a file
```

В этом примере класс `FileUtils` группирует методы, связанные с операциями над файлами, обеспечивая ясный и организованный способ работы с файлами.

Осознав эти сценарии, вы можете эффективно использовать мощь статических методов в вашем коде на Python и создать более поддерживаемое и организованное программное обеспечение. Статические методы предлагают чистый и краткий способ инкапсуляции функциональности, которая не зависит от данных конкретного экземпляра, улучшая читаемость кода и его поддержку.
  
## Сравнение Статических Классов и Обычных Классов  

Статические классы в Python - это классы, имеющие атрибуты и методы уровня класса, к которым можно получить доступ без создания экземпляра класса. Они определяются с помощью декоратора `@staticmethod`. В отличие от них, обычные классы в Python - это те, для доступа к атрибутам или методам которых требуется объект класса.

### Python Статический Класс

```python
class StaticClass:
    @staticmethod
    def my_static_method():
        print("This is a static method")

# Call static method in class
StaticClass.my_static_method()
```

В приведенном выше примере мы определили статический класс `StaticClass` со статическим методом `my_static_method`. Этот метод можно вызвать, не создавая экземпляр класса.

## Как Использовать Статические Классы в Python

Статические классы в Python — это классы, которые используются для группировки функций, которые не могут быть классифицированы в существующие классы. Для доступа к этим классам не требуется создавать экземпляр класса. Вместо этого статические методы могут быть вызваны напрямую из самого класса. Вот некоторые из основных преимуществ использования статических классов:

1. **Организация пространства имен** - Статические классы могут быть использованы для организации функций, которые не подходят ни под один из существующих классов. Это помогает поддерживать чистую и организованную структуру кода.

2. **Повторное использование кода** - Статические классы могут быть использованы в различных модулях и функциях, делая код повторно используемым и легким для поддержки.

3. **Улучшение читаемости кода** - Статические классы облегчают чтение и понимание кода, так как функции группируются под одним классом и к ним можно получить доступ напрямую.

```python
class MathUtils:
    @staticmethod
    def add_numbers(a, b):
        return a + b

result = MathUtils.add_numbers(2, 3)
print(result)
```

В этом примере мы создали статический класс `MathUtils` и определили статический метод `add_numbers`, который принимает два аргумента и возвращает их сумму. Статический метод может быть вызван напрямую из класса `MathUtils` без создания экземпляра класса.

```python
class StringUtils:
    @staticmethod
    def reverse_string(string):
        return string[::-1]

class TextUtils:
    @staticmethod
    def reverse_and_uppercase(string):
        reversed_string = StringUtils.reverse_string(string)
        return reversed_string.upper()

result = TextUtils.reverse_and_uppercase("Hello World")
print(result)
```

В этом примере, мы создали два статических класса `StringUtils` и `TextUtils`. Класс `StringUtils` содержит статический метод `reverse_string`, который возвращает перевернутую строку. Класс `TextUtils` содержит статический метод `reverse_and_uppercase`, который вызывает метод `reverse_string` из класса `StringUtils` и возвращает перевернутую строку в верхнем регистре.

## Статические Переменные в Классе

В Python, статические переменные - это переменные уровня класса, которые разделяются между всеми экземплярами класса. Эти переменные определены внутри класса, но вне любого метода, и они сохраняют свое значение через разные экземпляры класса.

Статические переменные полезны, когда вы хотите хранить данные, которые разделяются всеми экземплярами класса, или когда вы хотите поддерживать счетчик или общую конфигурацию для всех экземпляров.

Вот два примера кода, которые демонстрируют использование статических переменных в классах Python:

### Пример 1: Счет Экземпляров

```python
class Car:
    # Static variable to keep track of the number of instances
    count = 0

    def __init__(self, name):
        self.name = name
        # Increment the count when a new instance is created
        Car.count += 1

# Creating instances of the Car class
car1 = Car("Tesla")
car2 = Car("BMW")
car3 = Car("Audi")

# Accessing the static variable using the class name
print("Total cars:", Car.count)  # Output: Total cars: 3
```

В приведенном выше примере переменная `count` является статической переменной, которая отслеживает количество созданных экземпляров `Car`. Она увеличивается в конструкторе (`__init__`) при создании нового экземпляра. Статическая переменная доступна через имя класса (`Car.count`).

### Пример 2: Общая Конфигурация

```python
class Circle:
    # Class-level constant for pi
    PI = 3.14159

    def __init__(self, radius):
        self.radius = radius

    def calculate_area(self):
        # Accessing the static variable inside an instance method
        area = Circle.PI * self.radius * self.radius
        return area

# Creating instances of the Circle class
circle1 = Circle(5)
circle2 = Circle(7)

# Calling the instance method to calculate the area
area1 = circle1.calculate_area()
area2 = circle2.calculate_area()

print("Area 1:", area1)  # Output: Area 1: 78.53975
print("Area 2:", area2)  # Output: Area 2: 153.93791

```

В этом примере переменная `PI` является статической переменной, которая хранит значение `pi`. Она используется внутри метода `calculate_area` для расчета площади круга. Статическая переменная доступна с использованием имени класса (`Circle.PI`).

Статические переменные разделяются между всеми экземплярами класса и доступны с использованием имени класса или через экземпляр класса. Они являются полезным инструментом для управления данными, которые общие для всех экземпляров или для поддержания общей конфигурации между объектами.

## Разница Между Методом Класса и Статическим Методом

Теперь, когда вы знакомы с методами класса и статическими методами, пришло время погрузиться в мир статического класса Python и его отличительные особенности.

Абстрактный метод класса определяется как метод, который объявлен, но не содержит реализации. Реализацию должен предоставить подкласс. Абстрактный метод определяется с использованием декоратора **@abstractmethod** в Python.

Методы класса используются для модификации класса или его свойств. Они определяются с использованием декоратора `@classmethod` и передают класс в качестве первого аргумента, а не экземпляр.

Статические методы Python вызываются на классе и не принимают никаких специальных первых аргументов. Они определяются с использованием декоратора `@staticmethod`.

### Основные Различия Между Методом Класса и Статическим Методом в Python

| Метод класса  | Статический метод  |
|---|---|
| Декоратор: **@classmethod** | Декоратор: **@staticmethod** |
| Первый аргумент: **cls** (сам класс) | Нет специального первого аргумента |
| Может изменять состояние класса или свойства | Не может изменять состояние класса или свойства |
| Полезно для операций, специфических для класса | Полезно для вспомогательных операций, не связанных с классом |
| Может получить доступ к переменным уровня класса | Не может получить доступ к переменным уровня класса |

### Пример 1: Метод Класса

```python
class Car:
    wheels = 4

    def __init__(self, make, model):
        self.make = make
        self.model = model

    @classmethod
    def set_wheels(cls, num_wheels):
        cls.wheels = num_wheels

car1 = Car('Toyota', 'Corolla')
print(car1.wheels) # Output: 4
Car.set_wheels(3)
print(car1.wheels) # Output: 3
```

### Пример 2: Статический Метод

```python
class Formatter:
    @staticmethod
    def format_string(string):
        return string.upper()

print(Formatter.format_string('hello')) # Output: 'HELLO'
```
