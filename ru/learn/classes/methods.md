> [!NOTE]
> Вы можете прочитать эту статью на сайте: https://diveintopython.org/ru/learn/classes/methods

Эта статья исследует тонкости работы с методами и функциями в классах на Python. В частности, мы углубляемся в важные концепции конструктора класса (или метода `__init__`), абстрактных методов класса и различие между методами класса и статическими методами. Так что, если вы хотите повысить свои знания о функциях в классе, читайте дальше!

## Овладение Конструктором Класса в Python

Мы можем определять функции в классе, известные как методы. Конструктор класса или метод `__init__` - это специальный метод, который вызывается, когда создается объект класса. Он используется для инициализации переменных экземпляра класса.

Абстрактный метод класса - это метод, который объявлен, но не содержит реализации. Он используется как шаблон для других методов, которые определены в подклассе.

Метод класса - это метод, который привязан к классу, а не к экземпляру класса. Его можно доступить с использованием имени класса.

Статический метод - это метод, который привязан к классу и не к экземпляру класса. Он не принимает никаких аргументов, таких как self или cls.

### Пример 1: Конструктор Класса

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person("John", 36)

print(p1.name)
print(p1.age)

# Output:
# John
# 36
```

В приведенном выше примере мы определили класс `Person` с конструктором, который инициализирует атрибуты имени и возраста класса. Затем мы создали объект класса `p1` и получили доступ к его атрибутам, используя точечную нотацию.

### Пример 2: Метод Класса Против Статического Метода

```python
class Calculator:
    @classmethod
    def add(cls, num1, num2):
        return num1 + num2
    
    @staticmethod
    def multiply(num1, num2):
        return num1 * num2

print(Calculator.add(2,3))
print(Calculator.multiply(2,3))
# Output:
# 5
# 6
```

В этом примере мы определили класс `Calculator` с двумя методами: `add` как метод класса и `multiply` как статический метод. Мы обращались к этим методам, используя имя класса `Calculator`, не создавая объект класса. Мы использовали декораторы `@classmethod` и `@staticmethod` для определения этих методов.

## Абстрактный Метод Класса в Python

Абстрактный метод класса - это метод, который объявлен в абстрактном базовом классе, но не имеет реализации. Он используется для определения метода, который должен быть реализован любым классом, наследующим от абстрактного класса. Абстрактные методы класса создаются с помощью декоратора `@abstractmethod`. Вот пример абстрактного метода класса в Python:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    def __init__(self, type):
        self.type = type

    @abstractmethod
    def area(self):
        pass

class Square(Shape):
    def __init__(self, side):
        super().__init__("Square")
        self.side = side

    def area(self):
        return self.side ** 2

my_square = Square(5)
print(my_square.area()) # Output: 25
```

## Перегрузка Методов

Перегрузка методов - это функция в Python, которая позволяет классу иметь несколько методов с одинаковым названием, но с разными параметрами. Эта функция помогает обеспечить гибкость и возможность повторного использования в дизайне кода. Это отличается от переопределения методов, которое позволяет подклассу предоставить свою реализацию метода, определенного в его суперклассе.

```python
class Example:
    def method(self, a):
        print("Method with one parameter:", a)
    
    def method(self, a, b):
        print("Method with two parameters:", a, b)  
```

```python
class Example:
    def method(self, a=None, b=None, c=None):
        if a != None and b == None and c == None:
            print("Method with one parameter:", a)
        
        elif a != None and b != None and c == None:
            print("Method with two parameters:", a, b)
            
        elif a != None and b != None and c != None:
            print("Method with three parameters:", a, b, c)
```

В первом примере мы определяем класс с двумя методами с одинаковым именем, но с разными параметрами. Python напрямую не поддерживает перегрузку методов, поэтому последнее определение метода перезаписывает предыдущее. Таким образом, когда мы создаем объект класса и вызываем `method`, мы получим вывод последнего определения метода.

Во втором примере мы определяем класс с одним `method`, который принимает несколько необязательных параметров. Мы можем использовать условные операторы для проверки количества переданных параметров и соответственно выводить `print` результат. Этот подход обеспечивает повторное использование кода, поскольку мы можем вызывать тот же `method` с разными параметрами.

## Публичные, Приватные и Защищенные Методы в Python

В Python мы можем различать публичные, приватные и защищенные методы на основе уровня доступа.

- **Публичные методы** - это те, к которым можно получить доступ откуда угодно, как внутри, так и вне класса.
- **Приватные методы** в классе Python - это те, к которым доступ возможен только изнутри класса.
- **Защищенные методы** - это те, к которым можно получить доступ только изнутри класса и его подклассов.

### Публичные Методы

Публичные методы доступны откуда угодно, как внутри, так и вне класса. Они играют значительную роль в взаимодействии с атрибутами и функциональностью класса. Когда разработчики создают метод без префикса подчеркивания, он автоматически становится публичным методом.

```python
class MyClass:
    def public_method(self):
        print("This is a public method")

obj = MyClass()
obj.public_method()  # Accessing the public method
```

Как показано в примере, `public_method()` доступен снаружи класса `MyClass`. Эти методы позволяют внешнему коду напрямую взаимодействовать с функционалом класса.

### Приватные Методы в Python

Приватные методы в Python предназначены для доступа только изнутри класса, в котором они определены. Они обозначаются путем добавления к имени метода двойного подчеркивания `__`.

```python
class MyClass:
    def __private_method(self):
        print("This is a private method")

obj = MyClass()
obj.__private_method()  # Attempting to access the private method (Raises an error)
```

Попытка доступа к закрытому методу извне класса приводит к AttributeError. Искажение имен в Python делает имя метода, начинающееся с двойного подчёркивания, более сложным для прямого доступа из внешнего кода. Эти методы используются для внутренних операций в классе, повышая инкапсуляцию и предотвращая случайное неправильное использование или переопределение.

### Защищённые Методы

Защищённые методы обозначаются добавлением к имени метода одного подчёркивания `_`. К ним можно обратиться из самого класса и его подклассов.

```python
class MyClass:
    def _protected_method(self):
        print("This is a protected method")

class SubClass(MyClass):
    def access_protected(self):
        self._protected_method()  # Accessing the protected method from a subclass

obj = SubClass()
obj.access_protected()  # Accessing the protected method from the subclass
```

Защищенные методы предоставляют способ разрешения подклассам доступ к определенным методам, одновременно предотвращая прямой доступ из внешнего кода. Однако, в отличие от некоторых других языков, Python не налагает строгих ограничений на видимость.

## Методы Геттеры и Сеттеры в Python

Python предлагает удобные методы геттеров и сеттеров для контроля доступа к приватным переменным экземпляра классов. Методы геттеров и сеттеров важны, поскольку без них приватные переменные экземпляра не были бы доступны извне класса.

Метод геттер позволяет получить доступ к значению приватной переменной экземпляра извне класса, а метод сеттер позволяет установить значение приватной переменной экземпляра извне класса.

Вот простой пример класса с методами геттера и сеттера:

```python
class MyClass:
    def __init__(self):
        self._value = None

    def get_value(self):
        return self._value

    def set_value(self, value):
        self._value = value

obj = MyClass()
obj.set_value(10)
print(obj.get_value())
```

Теперь вы можете использовать эти методы для доступа и установки значения атрибута `value` класса `MyClass`.

```python
class MyClass:
    def __init__(self):
        self._value = None

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        self._value = value

obj = MyClass()
obj.value = 10
print(obj.value) 
```

Теперь вы можете использовать свойство `value` класса `MyClass` для получения и установки значения атрибута `value`:

В заключение, методы геттеров и сеттеров предоставляют контролируемый способ доступа и установки значений приватных переменных экземпляра в классах Python.

## Метод vs Функция

В Python и методы, и функции используются для выполнения определенной задачи. Однако между ними есть некоторые отличия.

### Функции

Функции определяются вне класса и могут быть вызваны в любом месте кода по их имени. Они принимают входные параметры и `возвращают` значение. Вот пример функции, которая принимает два числа в качестве входных данных и возвращает их сумму:

```python
def add_numbers(x, y):
    return x + y

result = add_numbers(3, 5)
print(result)  # Output: 8
```

Чтобы использовать эту функцию, мы можем вызвать её и предоставить входные параметры:

### Методы

Методы, с другой стороны, определяются внутри классов и вызываются на экземплярах этого класса. Они имеют доступ к атрибутам экземпляра и могут изменять его состояние.

Вот пример метода, который принимает один входной параметр и изменяет состояние экземпляра:

```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
        self.speed = 0

    def accelerate(self, speed):
        self.speed += speed

my_car = Car("Toyota", "Corolla")
my_car.accelerate(20)
print(my_car.speed)  # Output: 20
```

В этом примере метод `accelerate()` определён внутри класса `Car` и вызывается на экземпляре класса `Car`. Он увеличивает скорость автомобиля, добавляя входной параметр к атрибуту `speed` экземпляра.

В целом, функции - это отдельные блоки кода, которые принимают входные параметры и возвращают значение, в то время как методы определены внутри классов и вызываются на экземплярах этого класса, с доступом к атрибутам экземпляра и возможностью изменять его состояние.

## Переопределение Метода Класса

Переопределение метода - это особенность объектно-ориентированного программирования, которая позволяет подклассу предоставлять другую реализацию метода, уже определённого в его суперклассе. В Python переопределение метода выполнено просто и достигается путём определения метода в подклассе с тем же именем, что и метод в суперклассе.

```python
class Parent:
  def my_method(self):
    print("Parent method called")

class Child(Parent):
  def my_method(self):
    print("Child method called")

obj = Child()
obj.my_method() ### prints Child method called

```

В этом примере класс `Child` наследуется от класса `Parent` и переопределяет метод `my_method()`. Когда мы создаем объект класса `Child` и вызываем `my_method()`, он напечатает `Child method called` вместо `Parent method called`.

```python
class Animal:
  def move(self):
    print("Animal is moving")

class Bird(Animal):
  def move(self):
    super().move()
    print("Bird is flying")

obj = Bird()
obj.move() ### prints "Animal is moving" and "Bird is flying

```

В этом примере класс `Bird` расширяет класс `Animal` и переопределяет метод класса `move()`. Однако, сначала он вызывает реализацию метода `move()` суперкласса, используя функцию `super()`, а затем добавляет свою реализацию `Bird is flying`. Вывод будет `Animal is moving` и `Bird is flying`.

Использование переопределения методов в Python позволяет обеспечить большую гибкость и настройку поведения ваших классов.
