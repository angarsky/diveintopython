> [!NOTE]
> Вы можете прочитать эту статью на сайте: https://diveintopython.org/ru/learn/variables/operations-with-variables

Python позволяет использовать различные операции и методы для работы с данными и выполнения различных задач. Давайте рассмотрим наиболее популярные, которые относятся ко всем типам переменных.

## Определение Типа

Существует несколько способов проверить тип переменной в Python. Давайте посмотрим, как проверить тип переменной в Python.

### Функция `type()`

Эта встроенная функция `type()` возвращает тип данных переменной, это эквивалент `typeof` в других языках программирования.

Давайте посмотрим, как печатать тип переменной в Python:

```python
x = 23
print(type(x))   # Output: <class 'int'>

y = 3.14
print(type(y))   # Output: <class 'float'>

z = "Hello, friend!"
print(type(z))   # Output: <class 'str'>

w = True
print(type(w))   # Output: <class 'bool'>
```

В этом примере функция `type()` используется для определения типа переменных `x`, `y`, `z` и `w`. Вывод показывает класс переменной.

### Функция `isinstance()`

Эта встроенная функция проверяет, является ли переменная экземпляром указанного класса или нет. С помощью этой функции мы можем легко проверить, является ли переменная `string` или нет.

Таким образом, здесь мы проверяем тип переменной в Python:


```python
x = 5
print(isinstance(x, int))  # Output: True

y = "hello"
print(isinstance(y, str))  # Output: True

z = [1, 2, 3]
print(isinstance(z, list))  # Output: True
```

### Использование Атрибута `__class__`

Этот атрибут возвращает класс объекта.

Пример:

```python
x = 17
print(x.__class__)  # Output: <class 'int'>

y = "hello"
print(y.__class__)  # Output: <class 'str'>

z = [1, 2, 3]
print(z.__class__)  # Output: <class 'list'>
```

Этот пример показывает, как печатать тип переменной в Python.

### Использование Функции `type()` с Утверждением `assert`

Это способ проверить тип переменной и вызвать ошибку, если тип не соответствует ожидаемому.

Пример:

```python
x = 98
assert type(x) == int

y = "hello"
assert type(y) == str

z = [1, 2, 3]
assert type(z) == list
```

Это способы получения типа переменной в Python, например, вы можете проверить, является ли переменная списком (см. пример выше).

## Удаление Переменных

### Использование оператора `del`

В Python оператор `del` используется для удаления переменной или элемента из списка, словаря или любого другого объекта коллекции. Синтаксис использования del:

```python
del object
```

Где `object` может быть переменной, элементом списка, элементом словаря или любым другим объектом.

Вот несколько примеров:

```python
# Delete a variable
x = 5
del x

# Delete an item from a list
my_list = [1, 2, 3, 4, 5]
del my_list[2]

# Delete an item from a dictionary
my_dict = {'a': 1, 'b': 2, 'c': 3}
del my_dict['b']
```

В первом примере переменная `x` удаляется с использованием оператора `del`. После выполнения оператора переменная `x` больше не существует.

Во втором примере третий элемент списка `my_list` удаляется с помощью `del my_list[2]`. После выполнения оператора `my_list` содержит элементы `[1, 2, 4, 5]`.

В третьем примере элемент с ключом `'b'` удаляется из словаря `my_dict` с использованием `del my_dict['b']`. После выполнения оператора `my_dict` содержит элементы `{'a': 1, 'c': 3}`.

Обратите внимание, что `del` удаляет только ссылку на объект, а не сам объект. Если объект по-прежнему где-то в коде ссылается, он не будет удален из памяти.

### Присваивание Переменной Значения `None`

Еще один метод очистки переменной - присвоить переменной значение `None`, чтобы указать, что у нее нет значения. Значение `None` - это встроенная константа, представляющая отсутствие значения. Вот пример:

```python
x = None
print(x)  # Output: None
```

В этом примере мы присваиваем переменной `x` значение `None`. Когда мы печатаем значение `x`, мы видим, что оно выводит `None`.

### Использование Функций `locals()` или `globals()`

Вы можете использовать функции `locals()` и `globals()`, чтобы получить доступ к локальному и глобальному пространствам имен соответственно. Эти функции возвращают словарь, который содержит все переменные и их значения в текущем пространстве имен. Вы можете использовать эти функции для удаления переменных из пространства имен с помощью оператора `del`.

Вот пример:

```python
def my_function():
    x = 5
    y = 10
    del locals()['y']
    print(x)
    print(y)  # This will raise a NameError

my_function()
```

В этом примере мы определяем функцию `my_function()`, которая создает две переменные `x` и `y`. Затем мы используем оператор del для удаления переменной `y` из локального пространства имен, используя `del locals()['y']`. После выполнения оператора `y` больше не определена в локальном пространстве имен, поэтому когда мы пытаемся напечатать ее значение, мы получаем `NameError`.

Вы также можете использовать функцию `globals()` для удаления переменных из глобального пространства имен. Вот пример:

```python
x = 5
y = 10

def my_function():
    del globals()['x']

my_function()

print(x)  # This will raise a NameError
print(y)  # Output: 10
```

В этом примере мы определяем две переменные `x` и `y` в глобальном пространстве имен. Затем мы определяем функцию `my_function()`, которая использует `del globals()['x']`, чтобы удалить переменную `x` из глобального пространства имен. После вызова функции `x` больше не определена в глобальном пространстве имен, поэтому когда мы пытаемся напечатать ее значение, мы получаем `NameError`. Однако `y` все еще определена в глобальном пространстве имен, поэтому мы можем напечатать ее значение без ошибок.

Кроме того, вы можете очистить все переменные из текущего пространства имен, используя функции `globals()` и `locals()`. Вот как вы можете это сделать:

```python
# Clear all global variables
for var in globals().copy():
    if var.startswith("__"):
        continue
    del globals()[var]

# Clear all local variables
for var in locals().copy():
    if var.startswith("__"):
        continue
    del locals()[var]
```

Приведенный выше код удалит все переменные из глобального и локального пространств имен, кроме встроенных переменных Python (которые начинаются с `__`). Имейте в виду, что это может быть опасно, поскольку это удалит все ваши переменные, и вы не сможете получить к ним доступ позже в вашей программе. Так что убедитесь, что вы используете это с осторожностью.

### Использование Метода `__del__()`

Метод `__del__()` — это специальный метод, который вызывается, когда объект собирается быть уничтоженным или собраным сборщиком мусора. Вы можете определить этот метод в вашем классе для выполнения любых задач по очистке, которые требуются перед уничтожением объекта.

Метод `__del__()` не принимает аргументов и не возвращает значение. Вот пример:

```python
class MyClass:
    def __init__(self, name):
        self.name = name
    
    def __del__(self):
        print(f"{self.name} has been deleted")
        
obj1 = MyClass("Object 1")
obj2 = MyClass("Object 2")
del obj1
```

В этом примере мы определяем класс `MyClass` с методом `__init__()`, который инициализирует переменную экземпляра name. Мы также определяем метод `__del__()`, который печатает сообщение при удалении объекта. Мы создаем два экземпляра класса `MyClass` и затем удаляем один из них с помощью оператора `del`.

Когда мы запускаем этот код, мы получаем следующий вывод:

```python
Object 1 has been deleted
```
Этот вывод указывает на то, что метод `__del__()` был вызван, когда объект `obj1` был удален.

Обратите внимание, что вызов метода `__del__()` не гарантируется во всех случаях. Например, если программа завершается внезапно, метод может не быть вызван. Поэтому, в целом, не стоит полагаться на этот метод для критически важных задач очистки. Вместо этого лучше использовать другие механизмы очистки, такие как операторы `with` или менеджеры контекста, где это возможно.

## Операции с Переменными

Мы уже рассмотрели присваивание переменных ранее. Но давайте также посмотрим, что еще мы можем делать с переменными.

### Копирование Переменной

Для копирования переменной в Python вы можете использовать оператор присваивания `=` или метод `copy()`. Однако важно отметить, что поведение этих методов может быть разным в зависимости от типа переменной.

- Поверхностное копирование: Когда вы используете оператор присваивания для копирования списка, словаря или других изменяемых объектов, вы создаете поверхностную копию. Это означает, что новая переменная ссылается на тот же объект в памяти, что и оригинальная переменная. Любые изменения, внесенные в оригинальную переменную, будут отражены в копии и наоборот. Например:

```python
original_list = [1, 2, 3]
copy_list = original_list  # Shallow copy
original_list[0] = 4
print(copy_list)  # Output: [4, 2, 3]
```

- Глубокое копирование: Если вы хотите создать в памяти новый объект, являющийся копией оригинальной переменной, вы можете использовать метод `copy()`. Это создает глубокую копию, что означает, что любые изменения, внесенные в оригинальную переменную, не будут отражены в копии и наоборот. Например:

```python
import copy

original_list = [1, 2, 3]
copy_list = copy.deepcopy(original_list)  # Deep copy
original_list[0] = 4
print(copy_list)  # Output: [1, 2, 3]
```

Важно использовать соответствующий метод для копирования переменных, чтобы избежать неожиданного поведения в вашем коде.

### Проверка, Определена ли Переменная

Вы можете использовать оператор `in` для проверки, была ли переменная определена или нет.

Вот пример:

```python
if 'my_variable' in locals() or 'my_variable' in globals():
    print('my_variable is defined')
else:
    print('my_variable is not defined')
```

Этот код проверяет, определена ли переменная `my_variable` в локальном или глобальном пространстве имен. Если она определена, код напечатает `'my_variable is defined'`, в противном случае он напечатает `'my_variable is not defined'`.

Обратите внимание, что если переменная была определена, но имеет значение `None`, этот метод все равно будет считать ее определенной. Если вы хотите специально проверить наличие значения, отличного от `None`, вы можете изменить код так:

```python
if 'my_variable' in locals() and locals()['my_variable'] is not None or 'my_variable' in globals() and globals()['my_variable'] is not None:
    print('my_variable is defined and has a non-None value')
else:
    print('my_variable is not defined or has a value of None')
```

 Этот код проверяет, что переменная не только определена, но и имеет значение, отличное от `None`. Если оба условия выполняются, он напечатает `'my_variable is defined and has a non-None value'`, в противном случае он напечатает `'my_variable is not defined or has a value of None'`.

### Проверка, Пуста ли Переменная

В Python существует несколько способов проверить, пуста ли переменная:

- Использование оператора `if` с именем переменной:

```python
if my_variable:
    # do something
    pass
else:
    # the variable is empty
    pass
```

Если `my_variable` пуста или оценивается как `False`, будет выполнен блок `else`.

- Использование оператора `not` с именем переменной:

```python
if not my_variable:
    # the variable is empty
    pass
else:
    # do something
    pass
```

Если `my_variable` пуста или оценивается как `False`, будет выполнен блок `if`.

- Использование встроенной функции `len()`:

```python
if len(my_variable) == 0:
    # the variable is empty
    pass
else:
    # do something
    pass
```
Если у `my_variable` длина равна 0, она считается пустой.

- Использование оператора `is` с `None`:

```python
if my_variable is None:
    # the variable is empty
    pass
else:
    # do something
    pass
```

Если `my_variable` равна `None`, она считается пустой. Однако важно отметить, что `None` — это специфическое значение в Python и не то же самое, что пустая строка, список или другие типы данных.

### Получение Имени Переменной

Переменные — это просто имена, которые ссылаются на объекты в памяти. В Python вы можете получить имя переменной, используя функции `locals()` или `globals()`, в зависимости от того, находится ли переменная в локальном или глобальном пространстве имен.

Вот пример:

```python
x = 42
var_name = [k for k,v in locals().items() if v is x][0]
print(var_name)
```

Этот код присваивает значение `42` переменной `x`. Затем он использует генератор списка для итерации по всем элементам в локальном пространстве имен и находит имя переменной, которое ссылается на объект со значением `x`. Наконец, он выводит это имя переменной, которое в данном случае является `x`.

Обратите внимание, что этот подход предполагает, что переменная имеет уникальное значение в пространстве имен, что может не всегда быть так. Также, в целом, не рекомендуется полагаться на имена переменных в логике вашего кода, так как это может сделать ваш код более хрупким и сложным для рефакторинга.

### Проверка Наличия Переменной

Вы можете проверить наличие переменной в Python, используя ключевое слово `in` вместе с функцией `locals()` или `globals()`. Вот пример:

```python
if 'my_variable' in locals():
    print("my_variable exists in the local scope.")

if 'my_variable' in globals():
    print("my_variable exists in the global scope.")
```

В приведенном выше примере мы проверяем наличие переменной с именем `my_variable` в локальной или глобальной области с использованием ключевого слова `in` с функцией `locals()` или `globals()` соответственно. Если переменная существует, мы печатаем сообщение, указывающее на ее наличие в указанной области.

Обратите внимание, что проверка наличия переменной с использованием ключевого слова `in` и функций `locals()` или `globals()` будет работать только для переменных, которые уже были определены в программе. Если вы не уверены, была ли переменная определена или нет, вы можете использовать блок `try`-`except` для перехвата исключения `NameError`, которое будет вызвано, если переменная не существует. Вот пример:

```python
try:
    my_variable
    print("my_variable exists.")
except NameError:
    print("my_variable does not exist.")
```

В этом примере мы пытаемся получить доступ к переменной `my_variable`, и если она не существует, вызывается исключение `NameError`. Мы перехватываем исключение с помощью блока except и печатаем сообщение, указывающее, что переменная не существует.

